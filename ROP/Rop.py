import struct

#todo: add 64-bit capabilities

class RopChain:

    __doc__=\
    '''

    RopChain is a class that was designed to make life easier while creating ROP exploits.

    There are two ways to create a rop chain:

        1) Add the pop_pop_ret addresses before creating the chain.

            ropChain.addPopRet(3,cleanup_addr)
            ropChain.addLink(func_addr,[p1,p2,p3])

        2) explicitaly add the address of each cleanup for each link.

            ropCHain.addLink(func_addr, [p1,p2,p3], pppr)

    When you are ready to create your payload, you can get the full rop chain with

        ropChain.getChain()
    '''


    chain = ""
    popRet = {}
    arch = "i386"

    def addPopRet(self,numPops,addr):
        RopChain.popRet[numPops] = addr

    def setArch(self, arch):
        """docstring for setArch"""
        RopChain.arch = arch


    @classmethod
    def getCleanup(self,key):
        if RopChain.popRet.has_key(key):
            return RopChain.popRet[key]
        else:
            return 0xdeadbeef

    def addLink(self, addr, args = None, cleanup = None):

        if RopChain.arch == "i386":
            if cleanup is None:
                if type(args) is list:
                    RopChain.chain += struct.pack('<II',addr,RopChain.getCleanup(len(args)))
                    for i in range(0,len(args)):
                        RopChain.chain += struct.pack('<I',args[i])
                elif type(args) is int:
                    RopChain.chain+=struct.pack('<III',addr,RopChain.getCleanup(1),args)
                elif args is None:
                    RopChain.chain+=struct.pack('<II',addr,RopChain.getChain(0))

            else:
                RopChain.chain += struct.pack('<II',addr,cleanup)
                if type(args) is list:
                    for i in range(0,len(args)):
                        RopChain.chain += struct.pack('<I',args[i])
                elif type(args) is int:
                    RopChain.chain+=struct.pack('<I',args)

        elif RopChain.arch == "amd64":

            if cleanup is None:
                if type(args) is list:
                    RopChain.chain += struct.pack('<QQ',addr,RopChain.getCleanup(len(args)))
                    for i in range(0,len(args)):
                        RopChain.chain += struct.pack('<Q',args[i])
                elif type(args) is int:
                    RopChain.chain+=struct.pack('<QQQ',addr,RopChain.getCleanup(1),args)
                elif args is None:
                    RopChain.chain+=struct.pack('<QQ',addr,RopChain.getChain(0))

            else:
                RopChain.chain += struct.pack('<QQ',addr,cleanup)
                if type(args) is list:
                    for i in range(0,len(args)):
                        RopChain.chain += struct.pack('<Q',args[i])
                elif type(args) is int:
                    RopChain.chain+=struct.pack('<Q',args)

    def getChain(self):
        return RopChain.chain



